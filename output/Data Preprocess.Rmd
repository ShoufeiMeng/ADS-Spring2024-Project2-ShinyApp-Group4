---
title: "Data Preprocess"
output: html_document
date: "2024-02-15"
---


Set gloabl options
```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path='figs/',
                      echo=T, warning=FALSE, message=FALSE)
```






Load the data manipulation libraries
```{r}
if (!require("DT")) install.packages('DT')
if (!require("dtplyr")) install.packages('dtplyr')
if (!require("lubridate")) install.packages('lubridate')
if (!require("ggmap")) install.packages('ggmap')
if (!require("choroplethrZip")) {
  # install.packages("devtools")
  library(devtools)
  install_github('arilamstein/choroplethrZip@v1.5.0')}

library(dtplyr)
library(dplyr)
library(DT)
library(lubridate)
```


Install shiny
```{r}
if (!require("shiny")) install.packages("shiny")
library(shiny)
if (!require("shinydashboard")) install.packages("shinydashboard")
library(shinydashboard)
if (!require("leaflet")) install.packages("leaflet")
library(leaflet)
if (!require("scales")) install.packages("scales")
library(scales)
#runExample("01_hello")
```


Load Data

```{r read data}
v1 <- read.csv("~/ADS-Spring2024-Project2-ShinyApp-Group4/data/FemaWebDisasterDeclarations.csv")
v2 <- read.csv("~/ADS-Spring2024-Project2-ShinyApp-Group4/data/DisasterDeclarationsSummaries.csv")
v3 <- read.csv("~/ADS-Spring2024-Project2-ShinyApp-Group4/data/PublicAssistanceApplicantsProgramDeliveries.csv")

```

Inspect the Data
```{r}
# View the first few rows of the data
head(v1)

# Summary statistics for each column
summary(v1)

# Structure of the data
str(v1)
```


Handle Missing Values
```{r}
library(dplyr)
library(tidyverse)
na_count <- v1 %>%
  summarise_all(~sum(is.na(.)))

print(na_count)

v1_sel <- v1 %>%
  select(disasterName, stateCode, declarationType, disasterNumber)

v2_sel <- v2 %>% 
  select(state, disasterNumber, incidentType,incidentBeginDate,incidentEndDate, designatedArea)

v3_sel <- v3 %>% 
  select(currentProjectCost, disasterNumber)





library(dplyr)
combined <- inner_join(v1_sel, v2_sel, by = "disasterNumber")
combined_df<- inner_join(combined, v3_sel, by = "disasterNumber")



```


Combine Disaster Type
```{r}
combined1 <- combined_df %>%
  mutate(DisasterCategory = case_when(
    incidentType %in% c("Dam/Levee Break", "Earthquake","Fire","Flood", "Freezing", "Tsunami", "Volcanic Eruption", "Mud/Landslide", "Drought") ~ "Natural Disasters",
    incidentType %in% c("Chemical", "Toxic Substances", "Human Cause", "Terrorist") ~ "Human-caused Disasters",
    incidentType %in% c("Coastal Storm","Hurricane","Tropical Storm","Severe Storm", "Snowstorm", "Winter Storm", "Severe Ice Storm", "Tornado", "Typhoon") ~ "Severe Weather",
    incidentType %in% c("Biological") ~ "Biological",
    TRUE ~ "Others"  # Default category for anything else
  ))

head(combined1,5)
```

Years for Map
```{r}
combined2 <- combined1 %>%
  mutate(
    incidentBeginMonth = format(ymd_hms(incidentBeginDate), "%Y-%m")
  )


combined2$Year <- sub("-.*", "", combined2$incidentBeginMonth)

#To sort the data frame in ascending order of year
combined2 <- combined2 %>%
  mutate(Year = as.numeric(Year)) %>%
  arrange(Year)

# Calculate the occurrence counts for each state and disaster type in each year
disaster_counts <- combined2 %>%
  group_by(state = stateCode, DisasterCategory,Year) %>%
  summarise(frequency = n()) 
head(disaster_counts)

# Calculate the cost of disaster for each state and disaster type in each year
head(combined2)
disaster_costs <- combined2 %>%
  group_by(stateCode, DisasterCategory,Year) %>%
  summarise(TotalProjectCost = sum(currentProjectCost, na.rm = TRUE), .groups = "drop")
head(disaster_costs,5)
```


Time Series
```{r}
combined3 <- combined %>%
  mutate(DisasterCategory = case_when(
    incidentType %in% c("Dam/Levee Break", "Earthquake","Fire","Flood", "Freezing", "Tsunami", "Volcanic Eruption", "Mud/Landslide", "Drought") ~ "Natural Disasters",
    incidentType %in% c("Chemical", "Toxic Substances", "Human Cause", "Terrorist") ~ "Human-caused Disasters",
    incidentType %in% c("Coastal Storm","Hurricane","Tropical Storm","Severe Storm", "Snowstorm", "Winter Storm", "Severe Ice Storm", "Tornado", "Typhoon") ~ "Severe Weather",
    incidentType %in% c("Biological") ~ "Biological",
    TRUE ~ "Others"  # Default category for anything else
  ))

combined4 <- combined3 %>%
  mutate(
    incidentBeginMonth = format(ymd_hms(incidentBeginDate), "%Y-%m")
  )



```



```{r}
monthly_disasters <- combined4 %>%
  group_by(incidentBeginMonth) %>%
  summarise(NumberOfDisasters = n())


print(monthly_disasters)

monthly_disasters$incidentBeginMonth <- as.Date(paste0(monthly_disasters$incidentBeginMonth, "-01"))
start_year <- as.numeric(format(min(monthly_disasters$incidentBeginMonth), "%Y"))
start_month <- as.numeric(format(min(monthly_disasters$incidentBeginMonth), "%m"))

plot(NumberOfDisasters ~ incidentBeginMonth, data = monthly_disasters, type = "l")

```

Calculate the occurrence counts for each state and disaster type
```{r}
disaster_counts_ts <- combined4 %>%
  group_by(state = stateCode, DisasterCategory) %>%
  summarise(frequency = n())


```



Time Series
```{r}
monthly_disasters$incidentBeginMonth <- as.Date(paste0(monthly_disasters$incidentBeginMonth, "-01"))
# Assuming the aggregation is done and you have monthly counts
# Converting to a ts object, assuming the start year and month are known (e.g., 2023 and 6)
start_year <- as.numeric(format(min(monthly_disasters$incidentBeginMonth), "%Y"))
start_month <- as.numeric(format(min(monthly_disasters$incidentBeginMonth), "%m"))
disaster_ts <- ts(monthly_disasters$NumberOfDisasters, start = c(start_year, start_month), frequency = 12)
install.packages("forecast")
library(forecast)

# AR Model
ar_model <- auto.arima(disaster_ts, max.p = 5, max.q = 0, max.d = 2, stepwise = FALSE, approximation = FALSE)

# MA Model
ma_model <- auto.arima(disaster_ts, max.p = 0, max.q = 5, max.d = 2, stepwise = FALSE, approximation = FALSE)

# ARMA Model
arma_model <- auto.arima(disaster_ts, max.p = 5, max.q = 5, max.d = 2, stepwise = FALSE, approximation = FALSE)

# ARIMA Model
arima_model <- auto.arima(disaster_ts, stepwise = FALSE, approximation = FALSE)


summary(ar_model)
summary(ma_model)
summary(arma_model)
summary(arima_model)
```



Plots 
```{r}
par(mfrow = c(5,1))
plot(disaster_ts, main = "Monthly Disaster Count", xlab = "Month", ylab = "Disaster Count")

# AR Model Plot
plot(forecast(ar_model), main = "AR Model Forecast")

# MA Model Plot
plot(forecast(ma_model), main = "MA Model Forecast")

# ARMA Model Plot
plot(forecast(arma_model), main = "ARMA Model Forecast")

# ARIMA Model Plot
plot(forecast(arima_model), main = "ARIMA Model Forecast")
```

```{r}
unique(disaster_counts$DisasterCategory)
```

```{r}
# combine disaster cost and count for each state each year
state_location <- read.csv("~/ADS-Spring2024-Project2-ShinyApp-Group4/data/UsStateLocation.csv")

combined_disaster <- inner_join(disaster_counts, disaster_costs, by = c("state"="stateCode", "Year", "DisasterCategory"))

head(combined_disaster)

write.csv(combined_disaster, "~/ADS-Spring2024-Project2-ShinyApp-Group4/data/DisasterFinal.csv")
```

```{r}
ui <- fluidPage(
  titlePanel("US Disaster Analysis"),
  sidebarLayout(
    sidebarPanel(
      selectInput("state", "State", choices = unique(combined_disaster$state)),
      selectInput("year", "Year", choices = unique(combined_disaster$Year)),
      selectInput("category", "Disaster Category", choices = unique(combined_disaster$DisasterCategory)),
      radioButtons("displayMetric", "Display Metric:",
                   choices = list("Disaster Count" = "frequency", "Total Project Cost" = "TotalProjectCost")),
      actionButton("update", "Update")
    ),
    mainPanel(
      leafletOutput("map"),
      textOutput("stats")
    )
  )
)

server <- function(input, output, session) {
  
  data_filtered <- reactive({
    req(input$state, input$year, input$category) # Ensure values are selected
    combined_disaster %>%
      filter(state == input$state, year == input$year, category == input$category)
  })
  
  # Render the map output
  output$map <- renderLeaflet({
    # Initial map: centered on the US
    leaflet() %>%
      addProviderTiles(providers$Esri.WorldStreetMap) %>% # Using a basic map layer
      setView(lng = -98.583333, lat = 39.833333, zoom = 4) # Coordinates for the US center
  })
  
  # Update the map based on selections
  observe({
    req(input$state) # Ensure a state is selected
    state_loc <- state_location %>% filter(state == input$state)
    
    # If state location is found, update the map
    if(nrow(state_loc) > 0) {
      leafletProxy("map", data = state_loc) %>%
        clearMarkers() %>% # Remove existing markers
        addMarkers(lng = state_loc$longitude, lat = state_loc$latitude, popup = input$state) %>%
        setView(lng = state_loc$longitude, lat = state_loc$latitude, zoom = 6)
    }
  })
  
  observe({
    data <- data_filtered() # Get the filtered data
    
    # Determine circle sizes based on the display metric
    sizes <- if(input$displayMetric == "frequency") {
      sqrt(data$frequency) * 1000 # Adjust the multiplier as needed for visual distinction
    } else {
      sqrt(data$TotalProjectCost / 1e6) * 100 # Adjust divisor and multiplier as needed
    }
    
    # Update the map with circles for each disaster category
    leafletProxy("map", data = data) %>%
      clearShapes() %>% # Clear existing shapes
      addCircles(lng = ~longitude, lat = ~latitude, radius = ~sizes,
                 popup = ~paste(DisasterCategory, "in", Year, ": ", input$displayMetric, "=", sizes),
                 fillColor = ~ifelse(DisasterCategory == "Natural Disasters", "red", "blue"),
                 color = "#000000", fillOpacity = 0.5)
  })
  
  # Render the stats output
  output$stats <- renderText({
    data <- data_filtered()
    if(is.null(data) || nrow(data()) == 0) {
      return("No data available for the selected options.")
    }
    count <- nrow(data())
    total_cost <- sum(data()$project_cost, na.rm = TRUE)
    
    paste("Disaster Count:", count, "Total Project Cost:", formatC(total_cost, format = "f", big.mark = ","))
  })
}

shinyApp(ui, server)
```

